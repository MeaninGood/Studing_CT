# 2467번_용액

## 사용하다 남은 헤어에센스 용기 두 개를 반납하면 새로운 용기에다가 남은 헤어에센스를 모아 줌
## 추가로 총 용량의 절반만큼의 헤어에센스를 채워줌
## 단, 총 용량을 넘쳐서 채워주지는 않음
## 헤어에센스 용기 N개
## i번째 용기에 헤어에센스 Ci㎖
## 적당한 순서로 헤어에센스를 교환해서 용량이 꽉 찬 헤어에센스 용기를 최대한 많이
## 용량이 꽉 찬 헤어에센스를 최대 몇 개 만들 수 있는지

'''
# 첫째 줄에는 헤어에센스 용기의 수 n, 헤어에센스 용기의 총 용량 x
# 다음 줄에 각 용기에 담겨있는 헤어에센스의 용량이 공백을 기준으로 주어짐
## 적당한 순서로 헤어에센스를 교환
## 용량이 꽉 찬 헤어에센스 용기를 몇 개 만들 수 있는지 출력

(입력)
7 13
0 1 2 3 5 8 13

(출력)
3

'''

'''
문제 해석 : 0ml 용기라도 3개만 있으면 꽉 찬 에센스를 받을 수 있다
추가로 반을 채워주기 때문에!

예를들어
1. 0ml + 0ml 가져가면 6.5ml 채워줌(0ml하나 반납)
2. 남은 0ml + 채워진 6.5ml 가져가면 6.5ml에 6.5ml 추가됨 - 13ml 완성(0ml반납)

즉, 최소 두 개의 합이 6.5ml만 되면 무조건 가득찬 용기 하나를 얻을 수 있음.
1. 6.5 ml + 0 ml = 6.5ml 용기에 6.5ml 채워주고 0ml 반납
2. 13ml 하나 완성
'''

import sys

n, m = map(int, sys.stdin.readline().split())

arr = list(map(int, sys.stdin.readline().split()))

arr.sort()

s = 0
e = n-1
x = n # 용량이 다 찬 용기는 제외시킬 것이기 때문에, n 값을 줄여야 함
cnt = 0

for i in range(n)[::-1] : # 역순으로 인덱스 돌면서
    if arr[i] == m : # 맨 끝에서부터 m과 같은 값이 있으면
        cnt += 1 # 카운트 해주고
        e = i - 1 # 인덱스 번호 빼줌
        x = n - cnt

while s < e : # arr[s]~arr[e]까지 돌면서 s가 e보다 작을 때만 실행
    
    # arr[s] + arr[e]가 m/2보다 클 때와 같은 뜻인데,
    # 나눗셈은 부동소수점에 의해 미세한 오차가 발생할 수 있으니
    # 2 * (arr[s] + arr[e]) >= m으로 표시해 줌
    # 결국 같은 뜻인데, 오차 위험성이 사라짐
    if (2 * (arr[s] + arr[e])) >= m :
        cnt += 1 # 카운트 1추가
        x -= 2 # 두 개씩 돌 거기 때문에 용량 다 차면 두 개 지워줌
        s += 1 # 찾으면 s를 뒤로 보내주고
        e -= 1 # e도 앞으로 보내줌
        
    else : # 2 * (arr[s] + arr[e])보다 작은 경우에는
        s += 1 # e는 고정해두고 s만 옮겨줌
        # 왜 와이? 양 끝을 돌기 때문에, arr[s] + arr[e]의 값이 커져야 함
        # 맨 앞에 제일 작은 수가 오니까 그보다 더 큰 수를 더해줘야 함

print(cnt + x // 3)


